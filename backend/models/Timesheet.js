const mongoose = require('mongoose');

const timesheetSchema = new mongoose.Schema({
  student: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Student',
    required: [true, 'Student reference is required']
  },
  project: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Project',
    default: null
  },
  loginTime: {
    type: Date,
    required: [true, 'Login time is required']
  },
  logoutTime: {
    type: Date,
    default: null
  },
  totalHours: {
    type: Number,
    default: 0,
    min: [0, 'Total hours cannot be negative']
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'approved', 'rejected'],
    default: 'active'
  },
  description: {
    type: String,
    maxlength: [500, 'Description cannot exceed 500 characters']
  },
  tasks: [{
    description: {
      type: String,
      required: true,
      maxlength: [200, 'Task description cannot exceed 200 characters']
    },
    timeSpent: {
      type: Number,
      required: true,
      min: [0, 'Time spent cannot be negative']
    },
    completed: {
      type: Boolean,
      default: false
    }
  }],
  breaks: [{
    startTime: {
      type: Date,
      required: true
    },
    endTime: {
      type: Date,
      default: null
    },
    duration: {
      type: Number,
      default: 0
    },
    reason: {
      type: String,
      maxlength: [100, 'Break reason cannot exceed 100 characters']
    }
  }],
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Admin',
    default: null
  },
  approvedAt: {
    type: Date,
    default: null
  },
  rejectionReason: {
    type: String,
    maxlength: [500, 'Rejection reason cannot exceed 500 characters']
  },
  hourlyRate: {
    type: Number,
    default: 0,
    min: [0, 'Hourly rate cannot be negative']
  },
  earnings: {
    type: Number,
    default: 0,
    min: [0, 'Earnings cannot be negative']
  },
  isAutoGenerated: {
    type: Boolean,
    default: true
  },
  ipAddress: {
    type: String,
    default: null
  },
  userAgent: {
    type: String,
    default: null
  },
  location: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  screenshots: [{
    filename: String,
    path: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  }],
  productivity: {
    score: {
      type: Number,
      min: [0, 'Productivity score cannot be negative'],
      max: [100, 'Productivity score cannot exceed 100'],
      default: 0
    },
    activeTime: {
      type: Number,
      default: 0
    },
    idleTime: {
      type: Number,
      default: 0
    }
  },
  date: {
    type: Date,
    default: function() {
      return new Date(this.loginTime).setHours(0, 0, 0, 0);
    }
  }
}, {
  timestamps: true
});

// Indexes for better query performance
timesheetSchema.index({ student: 1, date: 1 });
timesheetSchema.index({ project: 1 });
timesheetSchema.index({ status: 1 });
timesheetSchema.index({ loginTime: 1 });
timesheetSchema.index({ student: 1, status: 1 });
timesheetSchema.index({ approvedBy: 1 });

// Virtual for calculating work duration
timesheetSchema.virtual('workDuration').get(function() {
  if (!this.logoutTime) return 0;
  return Math.round((this.logoutTime - this.loginTime) / (1000 * 60 * 60) * 100) / 100;
});

// Virtual for calculating break duration
timesheetSchema.virtual('totalBreakTime').get(function() {
  return this.breaks.reduce((total, breakItem) => {
    return total + (breakItem.duration || 0);
  }, 0);
});

// Virtual for calculating net work time
timesheetSchema.virtual('netWorkTime').get(function() {
  return Math.max(0, this.workDuration - this.totalBreakTime);
});

// Virtual for checking if timesheet is active
timesheetSchema.virtual('isActive').get(function() {
  return this.status === 'active' && !this.logoutTime;
});

// Method to logout and calculate total hours
timesheetSchema.methods.logout = function() {
  if (this.logoutTime) {
    throw new Error('Already logged out');
  }
  
  this.logoutTime = new Date();
  this.totalHours = this.netWorkTime;
  this.status = 'completed';
  
  // Calculate earnings if hourly rate is available
  if (this.hourlyRate > 0) {
    this.earnings = this.totalHours * this.hourlyRate;
  }
  
  return this.save();
};

// Method to start a break
timesheetSchema.methods.startBreak = function(reason = '') {
  // Check if there's already an active break
  const activeBreak = this.breaks.find(b => !b.endTime);
  if (activeBreak) {
    throw new Error('Break already in progress');
  }
  
  this.breaks.push({
    startTime: new Date(),
    reason: reason
  });
  
  return this.save();
};

// Method to end a break
timesheetSchema.methods.endBreak = function() {
  const activeBreak = this.breaks.find(b => !b.endTime);
  if (!activeBreak) {
    throw new Error('No active break found');
  }
  
  activeBreak.endTime = new Date();
  activeBreak.duration = Math.round((activeBreak.endTime - activeBreak.startTime) / (1000 * 60 * 60) * 100) / 100;
  
  return this.save();
};

// Method to add a task
timesheetSchema.methods.addTask = function(description, timeSpent = 0) {
  this.tasks.push({
    description: description,
    timeSpent: timeSpent,
    completed: false
  });
  
  return this.save();
};

// Method to complete a task
timesheetSchema.methods.completeTask = function(taskId) {
  const task = this.tasks.id(taskId);
  if (!task) {
    throw new Error('Task not found');
  }
  
  task.completed = true;
  return this.save();
};

// Method to approve timesheet
timesheetSchema.methods.approve = function(adminId) {
  if (this.status !== 'completed') {
    throw new Error('Only completed timesheets can be approved');
  }
  
  this.status = 'approved';
  this.approvedBy = adminId;
  this.approvedAt = new Date();
  
  // Calculate final earnings
  if (this.project) {
    // Get hourly rate from project if not set
    this.populate('project', 'hourlyRate').then(() => {
      if (this.project && this.project.hourlyRate) {
        this.hourlyRate = this.project.hourlyRate;
        this.earnings = this.totalHours * this.hourlyRate;
      }
    });
  }
  
  return this.save();
};

// Method to reject timesheet
timesheetSchema.methods.reject = function(adminId, reason) {
  if (this.status !== 'completed') {
    throw new Error('Only completed timesheets can be rejected');
  }
  
  this.status = 'rejected';
  this.approvedBy = adminId;
  this.approvedAt = new Date();
  this.rejectionReason = reason;
  this.earnings = 0;
  
  return this.save();
};

// Static method to get active timesheets
timesheetSchema.statics.getActiveTimesheets = function() {
  return this.find({ status: 'active', logoutTime: null })
    .populate('student', 'name email')
    .populate('project', 'title');
};

// Static method to get timesheets for approval
timesheetSchema.statics.getPendingApproval = function(limit = 20) {
  return this.find({ status: 'completed' })
    .populate('student', 'name email')
    .populate('project', 'title hourlyRate')
    .sort({ logoutTime: -1 })
    .limit(limit);
};

// Static method to get student's timesheets
timesheetSchema.statics.getStudentTimesheets = function(studentId, startDate = null, endDate = null) {
  const query = { student: studentId };
  
  if (startDate || endDate) {
    query.date = {};
    if (startDate) query.date.$gte = new Date(startDate);
    if (endDate) query.date.$lte = new Date(endDate);
  }
  
  return this.find(query)
    .populate('project', 'title hourlyRate')
    .sort({ loginTime: -1 });
};

// Pre-save middleware to calculate total hours and earnings
timesheetSchema.pre('save', function(next) {
  // Calculate total hours if logout time is set
  if (this.logoutTime && this.loginTime) {
    const workDuration = (this.logoutTime - this.loginTime) / (1000 * 60 * 60);
    const breakDuration = this.breaks.reduce((total, breakItem) => total + (breakItem.duration || 0), 0);
    this.totalHours = Math.max(0, Math.round((workDuration - breakDuration) * 100) / 100);
  }
  
  // Calculate earnings if approved and hourly rate is available
  if (this.status === 'approved' && this.hourlyRate > 0 && this.totalHours > 0) {
    this.earnings = Math.round(this.totalHours * this.hourlyRate * 100) / 100;
  }
  
  // Set date based on login time
  if (this.loginTime) {
    this.date = new Date(this.loginTime).setHours(0, 0, 0, 0);
  }
  
  next();
});

module.exports = mongoose.model('Timesheet', timesheetSchema);
